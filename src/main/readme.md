# テスト駆動開発の練習

テスト駆動開発のサイクル

1. 小さなテストを1つ書く
2. 全てのテストを実行し、1つ失敗することを確認する
3. 小さな変更を行う
4. 再びテストを実行し、全て成功することを確認する
5. リファクタリングを行い、重複を除去する

テスト駆動開発の流れ  
1. テストを書く
2. 動かす
3. 正しくする

## 1章

現状  - レポートの内容  

| 銘柄  | 株数   | 価格  | 合計    |
|-----|------|-----|-------|
| IBM | 1000 | 25  | 25000 |
| GE  | 400  | 100 | 40000 |
総計 65000  

↓  

今後 - 通貨を追加したレポート  

| 銘柄  | 株数   | 価格      | 合計        |
|-----|------|---------|-----------|
| IBM | 1000 | 25 USD  | 25000 USD |
| GE  | 400  | 150 CHF | 60000 CHF |
総計 65000 USD  

為替レートも必要  

| 換算元 | 換算先   | レート     | 
|-----|------|---------|
| CHF | USD | 1.5  |

レポートを多国通貨に対応させる方法を検討していくことが課題  

## 1章の振り返り

書くべきテストのリストを作成
どうなれば嬉しいのかを小さいコードを使って確認
空実装を使ってコンパイラを通した
とにかくテストを通した
動くコードを徐々に共通かしてベタ書きの値を変数に置き換えた
TODOリストに項目を追加するにとどめて、一度に多くのものへ取り組むのをさけた

## 2章

Dollarの副作用の解消がテーマの章  

仮実装と明白な実装  
仮実装では、コードでまずベタ書きの値を使って、実装を進めるに従って徐々に変数に置き換える  
明白な実装では、すぐに頭の中の実装をコードに落とす  
→ これはTDDにおいて素早くグリーンにするための、2つの戦略

## 3章

Value Objectに関して  

人間界だと、ある整数に1を足すとき、元の整数が変更されるとは考えない  
新しい値が得られると考える  

一方、オブジェクトの振る舞いは異なり  
保険契約のオブジェクトがあるとして、契約条項に1つ条項を加えたら、元の保険契約の契約条項が変更される  

基本的にこのように変化し続けるオブジェクトを値として扱うこともできる=Value Objectパターン  

Value Objectにはコンストラクタで設定したインスタンス変数の値が変わってはならない  

Value Object を利用するメリットは別名参照(aliasing)を気にする必要がなくなること  

別名参照問題の例

小切手オブジェクトを作成、その金額を5ドルオブジェクトを示すDollarインスタンスを代入  
また別の小切手オブジェクトを作成し、同じDollarインスタンス(5ドル)を代入した場合を考える  

ある時、最初の小切手オブジェクトの金額(Dollar)の値を変更すると、意図せず2つ目の小切手の金額の値も変更される  
これを別名参照問題と呼ぶ  

Value Objectを利用すると 5ドルオブジェクトがあれば、永遠に5ドルのまま
7ドルを必要とする場合は、新しいオブジェクトを作る必要がある

## 3章の振り返り

value Object の使い方を理解できた

## 4章

Dollar Objectを利用できるところを追加でリファクタリング
テストとオブジェクト間の依存を解消できた

## 5章

既存のDollarオブジェクトを流用して、Francオブジェクトを作成する  

設計とTDDの両立について  

コピーペーストによる再利用は、抽象化の敗北では？という議論  
設計を軽視してもいい、言い訳になるのではという懸念も挙げられる  

↓

TDDのフェーズは、各フェーズごとに目的と解決策がある

もう一度TDDのフェーズを振り返る

1. テストを書く
2. コンパイラを通す
3. テストを走らせ、失敗を確認する
4. テストを通す
5. 重複を排除する

最初の3つのフェーズはなるべく早く通過して、  
新しい機能がどのような状態にあるのかわかるところまでにしたい  

この3つのフェーズにおいては速度が設計よりも大事  
ただ、設計を軽視しても良いとは言ってないので、4,5のフェーズではそれを理解しておくこと

## 6章

リファクタリングと不足したテストコードの追加

継承

Money クラスのフィールド amount の アクセス修飾子としては protected  
サブクラスからフィールドを見えるように指定する必要があるため使用している

やったことは
Dollarクラスから親クラスMoneyへ段階的にメソッドを移動する
Francも同様に対処した
2つ目のequalsメソッドの差異無くしてから、サブクラス側の実装を削除

## 7章

Dollar と Franc の比較  → ドルとフランが等しい状態になってるので明らかにおかしい
2つのMoneyオブジェクトの金額と実クラスが共に等しい時のみ等価であると判定するコードを追加

やったこと
- 悩みをテストコードへ
- 完璧ではないが、getClassでテストを通るように修正できた
- より良い設計は必要になる時まで先延ばしにする

